# **Day1**

# P1000 超级玛丽游戏

## 题目背景

本题是洛谷的试机题目，可以帮助了解洛谷的使用。

建议完成本题目后继续尝试 [P1001](/problem/P1001)、[P1008](/problem/P1008)。  

## 题目描述

超级玛丽是一个非常经典的游戏。请你用字符画的形式输出超级玛丽中的一个场景。

```
                ********
               ************
               ####....#.
             #..###.....##....
             ###.......######              ###            ###
                ...........               #...#          #...#
               ##*#######                 #.#.#          #.#.#
            ####*******######             #.#.#          #.#.#
           ...#***.****.*###....          #...#          #...#
           ....**********##.....           ###            ###
           ....****    *****....
             ####        ####
           ######        ######
##############################################################
#...#......#.##...#......#.##...#......#.##------------------#
###########################################------------------#
#..#....#....##..#....#....##..#....#....#####################
##########################################    #----------#
#.....#......##.....#......##.....#......#    #----------#
##########################################    #----------#
#.#..#....#..##.#..#....#..##.#..#....#..#    #----------#
##########################################    ############
```

## 输入格式

无

## 输出格式

如描述



my code:

```c++
#include <iostream>
int main(){
    std::cout<<"                ********"<<std::endl;
    std::cout<<"               ************"<<std::endl;
    std::cout<<"               ####....#."<<std::endl;
    std::cout<<"             #..###.....##...."<<std::endl;
    std::cout<<"             ###.......######              ###            ###"<<std::endl;
    std::cout<<"                ...........               #...#          #...#"<<std::endl;
    std::cout<<"               ##*#######                 #.#.#          #.#.#"<<std::endl;
    std::cout<<"            ####*******######             #.#.#          #.#.#"<<std::endl;
    std::cout<<"           ...#***.****.*###....          #...#          #...#"<<std::endl;
    std::cout<<"           ....**********##.....           ###            ###"<<std::endl;
    std::cout<<"           ....****    *****...."<<std::endl;
    std::cout<<"             ####        ####"<<std::endl;
    std::cout<<"           ######        ######"<<std::endl;
    std::cout<<"##############################################################"<<std::endl;
    std::cout<<"#...#......#.##...#......#.##...#......#.##------------------#"<<std::endl;
    std::cout<<"###########################################------------------#"<<std::endl;
    std::cout<<"#..#....#....##..#....#....##..#....#....#####################"<<std::endl;
    std::cout<<"##########################################    #----------#"<<std::endl;
    std::cout<<"#.....#......##.....#......##.....#......#    #----------#"<<std::endl;
    std::cout<<"##########################################    #----------#"<<std::endl;
    std::cout<<"#.#..#....#..##.#..#....#..##.#..#....#..#    #----------#"<<std::endl;
    std::cout<<"##########################################    ############"<<std::endl;
}
```

最笨的办法，一行行复制就行了，不过后面看到题解有人用了个raw string literals这个东西，不太了解哈，因为我是java转c转c++，c++就是边学边做题和看书，不过万能的gpt出手了，后续贴上。先看代码

```c++
#include <iostream>
int main(){
    std::cout<<R"(                ********
               ************
               ####....#.
             #..###.....##....
             ###.......######              ###            ###
                ...........               #...#          #...#
               ##*#######                 #.#.#          #.#.#
            ####*******######             #.#.#          #.#.#
           ...#***.****.*###....          #...#          #...#
           ....**********##.....           ###            ###
           ....****    *****....
             ####        ####
           ######        ######
##############################################################
#...#......#.##...#......#.##...#......#.##------------------#
###########################################------------------#
#..#....#....##..#....#....##..#....#....#####################
##########################################    #----------#
#.....#......##.....#......##.....#......#    #----------#
##########################################    #----------#
#.#..#....#..##.#..#....#..##.#..#....#..#    #----------#
##########################################    ############ )"<<std::endl;
}
```

## GPT说：

"C++11引入了原始字符串字面量（**raw string literals**）的概念。在C++中，通常字符串字面量由双引号括起来，例如："Hello, World!"。然而，这种方式可能会导致转义字符的使用变得复杂，尤其是当字符串中包含大量的反斜杠（\）时。原始字符串字面量允许你创建不需要转义字符的字符串字面量。它们由一对R"("和")"括起来，中间可以包含任意字符序列，包括换行符和双引号，直到遇到右括号为止。"

例如，使用原始字符串字面量，上面的字符串可以这样表示：

```c++
R"(Hello, World!)"
```

这样就避免了对反斜杠进行转义，使得代码更加清晰和易读。原始字符串字面量对于包含大量特殊字符或需要保持格式的文本非常有用。

“在C++中，字符串字面量中的某些字符可能需要使用反斜杠进行转义，以表示特殊含义。例如，`\n`表示换行符，`\t`表示制表符，`\"`表示双引号，等等。这意味着如果你想要在字符串中直接包含一个反斜杠字符，**你需要使用`\\`来表示一个反斜杠字符本身。**使用原始字符串字面量可以避免这种转义。例如，在原始字符串字面量中，反斜杠不会被解释为转义字符。这意味着你可以直接包含反斜杠字符而无需转义。这使得在字符串中包含路径、正则表达式、JSON 数据等内容更加简单和直观。”

"C++11是C++语言的一个版本，是C++标准的第一个重大更新，于2011年发布。它引入了许多新特性和改进，包括：

1. 自动类型推导（auto关键字）
2. Lambda表达式
3. 范围-based for 循环
4. nullptr 关键字
5. 引入智能指针（std::unique_ptr、std::shared_ptr、std::weak_ptr）
6. 原始字符串字面量（Raw string literals）
7. 静态断言（static_assert）
8. 新的容器和算法
9. 并发编程支持（std::thread、std::mutex 等）
10. 委托构造函数（Delegating constructors）
11. 移动语义和右值引用
12. constexpr函数
13. 用户定义的字面量（User-defined literals）
14. 增强型枚举（Scoped enums）

这些改进使得C++11更加现代化、易用和安全，同时提高了代码的表现力和性能。C++11也奠定了后续C++标准的基础，为未来的C++发展铺平了道路。"

# P1001 A+B Problem

## 题目描述

输入两个整数 $a, b$，输出它们的和（$|a|,|b| \le {10}^9$）。

注意

1. Pascal 使用 `integer` 会爆掉哦！
2. 有负数哦！
3. C/C++ 的 main 函数必须是 `int` 类型，而且 C 最后要 `return 0`。这不仅对洛谷其他题目有效，而且也是 NOIP/CSP/NOI 比赛的要求！

好吧，同志们，我们就从这一题开始，向着大牛的路进发。

> 任何一个伟大的思想，都有一个微不足道的开始。

## 输入格式

两个以空格分开的整数。

## 输出格式

一个整数。

## 样例 #1

### 样例输入 #1

```
20 30
```

### 样例输出 #1

```
50
```

简单题不多说了

```c++
#include <iostream>
int main(){
    int a=0,b=0;
    std::cin>>a>>b;
    std::cout<<a+b<<std::endl;
}
```



# [NOIP2002 普及组] 级数求和

## 题目描述

已知：$S_n= 1+\dfrac{1}{2}+\dfrac{1}{3}+…+\dfrac{1}{n}$。显然对于任意一个整数 $k$，当 $n$ 足够大的时候，$S_n>k$。

现给出一个整数 $k$，要求计算出一个最小的 $n$，使得 $S_n>k$。

## 输入格式

一个正整数 $k$。

## 输出格式

一个正整数 $n$。

## 样例 #1

### 样例输入 #1

```
1
```

### 样例输出 #1

```
2
```

## 提示

**【数据范围】**

对于 $100\%$ 的数据，$1\le k \le 15$。

**【题目来源】**

NOIP 2002 普及组第一题

my code：

```c++
#include <iostream>
int main(){
    int k=0,n=1;
    double sn=0;
    std::cin>>k;
    for(n=1;;n++){
	 sn+=1.0/n;
	 if(sn>k)
	  break;
    }
    std::cout<<n<<std::endl;
    return 0;   
}
```

这里出现了问题啊就是这段代码

```c++
    for(n=1;;n++){
	 sn+=1.0/n;
	 if(sn>k)
	  break;
    }
```

我从评论区弄得，发现就是这段有问题，原来这一块我用的是如下

```c++
while(sn<k){
        sn+=1.0/n;
        n++;
    }
```

但是死活通过不了，理论上两个逻辑是一样的，我想导出错误信息，但是没有实名认证不行，我问了GPT,他说：

"在洛谷（Luogu）评测系统中，可能会有一些特定的限制或者测试用例，导致两种循环结构的表现有所不同。虽然这两种循环结构在逻辑上是等价的，并且都可以正确地解决问题，但评测系统可能对其进行了不同的处理。以下是一些可能导致这种现象的原因：

1. **测试用例不同：** 评测系统可能针对不同的输入数据提供不同的测试用例，其中可能包含一些边界情况或特殊情况。这些情况可能会导致某些代码通过而另一些不通过。
2. **编译器或环境差异：** 评测系统可能使用不同版本的编译器或运行环境来编译和运行代码。由于编译器和运行环境的差异，某些代码可能在某些环境中能够正常运行而在其他环境中出现问题。
3. **性能问题：** 评测系统可能对代码的执行时间和内存占用等性能指标进行限制。一种循环结构可能比另一种更有效率，因此可能会更容易通过性能限制。
4. **评测系统的策略：** 评测系统可能使用不同的评测策略来评判代码的正确性。某些评测系统可能更严格地检查代码的行为，而另一些则可能更宽松。

针对这种情况，你可以尝试以下几种方法来找出问题的原因：

- 仔细查看评测系统提供的错误信息，了解代码未通过的具体原因。
- 分析两种循环结构在不同情况下的行为，找出可能的区别。
- 使用调试工具或添加输出语句来调试代码，找出问题所在。
- 尝试优化代码，以满足评测系统的性能要求。

如果你能提供更多关于代码未通过的信息，我可以帮助你更具体地分析问题所在。"

好的，以后有能力了来处理下吧，确实很好奇。

