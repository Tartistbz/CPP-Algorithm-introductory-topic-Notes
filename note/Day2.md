# P1046 [NOIP2005 普及组] 陶陶摘苹果

## 题目描述

陶陶家的院子里有一棵苹果树，每到秋天树上就会结出 $10$ 个苹果。苹果成熟的时候，陶陶就会跑去摘苹果。陶陶有个 $30$ 厘米高的板凳，当她不能直接用手摘到苹果的时候，就会踩到板凳上再试试。


现在已知 $10$ 个苹果到地面的高度，以及陶陶把手伸直的时候能够达到的最大高度，请帮陶陶算一下她能够摘到的苹果的数目。假设她碰到苹果，苹果就会掉下来。

## 输入格式

输入包括两行数据。第一行包含 $10$ 个 $100$ 到 $200$ 之间（包括 $100$ 和 $200$）的整数（以厘米为单位）分别表示 $10$ 个苹果到地面的高度，两个相邻的整数之间用一个空格隔开。第二行只包括一个 $100$ 到 $120$ 之间（包含 $100$ 和 $120$）的整数（以厘米为单位），表示陶陶把手伸直的时候能够达到的最大高度。

## 输出格式

输出包括一行，这一行只包含一个整数，表示陶陶能够摘到的苹果的数目。

## 样例 #1

### 样例输入 #1

```
100 200 150 140 129 134 167 198 200 111
110
```

### 样例输出 #1

```
5
```

## 提示

**【题目来源】**

NOIP 2005 普及组第一题

my code:

```c++
#include <iostream>
int main(){
    int count=0;
    int a[1][10];
    for(int i=0;i<10;i++){
        std::cin>>a[0][i];
    }
    std::cin>>a[0][0];
    for(int i=0;i<10;i++){
        if(a[0][0]+30>=a[0][i]){
            count++;
        }
    }
    std::cout<<count<<std::endl;
}
```

我个人是采用二维数组遍历进行输入，这是比较纯的模拟题了

# P1047 [NOIP2005 普及组] 校门外的树

## 题目描述

某校大门外长度为 $l$ 的马路上有一排树，每两棵相邻的树之间的间隔都是 $1$ 米。我们可以把马路看成一个数轴，马路的一端在数轴 $0$ 的位置，另一端在 $l$ 的位置；数轴上的每个整数点，即 $0,1,2,\dots,l$，都种有一棵树。


由于马路上有一些区域要用来建地铁。这些区域用它们在数轴上的起始点和终止点表示。已知任一区域的起始点和终止点的坐标都是整数，区域之间可能有重合的部分。现在要把这些区域中的树（包括区域端点处的两棵树）移走。你的任务是计算将这些树都移走后，马路上还有多少棵树。

## 输入格式

第一行有两个整数，分别表示马路的长度 $l$ 和区域的数目 $m$。

接下来 $m$ 行，每行两个整数 $u, v$，表示一个区域的起始点和终止点的坐标。

## 输出格式

输出一行一个整数，表示将这些树都移走后，马路上剩余的树木数量。

## 样例 #1

### 样例输入 #1

```
500 3
150 300
100 200
470 471
```

### 样例输出 #1

```
298
```

## 提示

**【数据范围】**

- 对于 $20\%$ 的数据，保证区域之间没有重合的部分。
- 对于 $100\%$ 的数据，保证 $1 \leq l \leq 10^4$，$1 \leq m \leq 100$，$0 \leq u \leq v \leq l$。

**【题目来源】**

NOIP 2005 普及组第二题

mycode:

```cpp
#include <iostream>    
#include <vector>
int main(){
   int l=0,m=0;
   int count=0;
   std::cin>> l >> m;
   std::vector<int> trees(l+1,1); //vector序列容器
   for(int j = 0; j < m ; j++){
      int u,v;
      std::cin>>u>>v;
      for (int i = u; i <= v; i++)
      {
         trees[i]=0;
      }
   }
   for (int i = 0; i <= l; i++)
   {
      if (trees[i]==1)
      {
         count++;
      }
   }
   std::cout<<count<<std::endl;   
}                                                    
```

# C++ vector 容器

C++ 中的 vector 是一种序列容器，它允许你在运行时动态地插入和删除元素。

vector 是基于数组的数据结构，但它可以自动管理内存，这意味着你不需要手动分配和释放内存。

与 C++ 数组相比，vector 具有更多的灵活性和功能，使其成为 C++ 中常用的数据结构之一。

vector 是 C++ 标准模板库（STL）的一部分，提供了灵活的接口和高效的操作。

**基本特性:**

- **动态大小**：`vector` 的大小可以根据需要自动增长和缩小。
- **连续存储**：`vector` 中的元素在内存中是连续存储的，这使得访问元素非常快速。
- **可迭代**：`vector` 可以被迭代，你可以使用循环（如 `for` 循环）来访问它的元素。
- **元素类型**：`vector` 可以存储任何类型的元素，包括内置类型、对象、指针等。

**使用场景：**

- 当你需要一个可以动态增长和缩小的数组时。
- 当你需要频繁地在序列的末尾添加或移除元素时。
- 当你需要一个可以高效随机访问元素的容器时。

# P1085 [NOIP2004 普及组] 不高兴的津津

## 题目描述

津津上初中了。妈妈认为津津应该更加用功学习，所以津津除了上学之外，还要参加妈妈为她报名的各科复习班。另外每周妈妈还会送她去学习朗诵、舞蹈和钢琴。但是津津如果一天上课超过八个小时就会不高兴，而且上得越久就会越不高兴。假设津津不会因为其它事不高兴，并且她的不高兴不会持续到第二天。请你帮忙检查一下津津下周的日程安排，看看下周她会不会不高兴；如果会的话，哪天最不高兴。

## 输入格式

输入包括 $7$ 行数据，分别表示周一到周日的日程安排。每行包括两个小于 $10$ 的非负整数，用空格隔开，分别表示津津在学校上课的时间和妈妈安排她上课的时间。

## 输出格式

一个数字。如果不会不高兴则输出 $0$，如果会则输出最不高兴的是周几（用 $1, 2, 3, 4, 5, 6, 7$ 分别表示周一，周二，周三，周四，周五，周六，周日）。如果有两天或两天以上不高兴的程度相当，则输出时间最靠前的一天。

## 样例 #1

### 样例输入 #1

```
5 3
6 2
7 2
5 3
5 4
0 4
0 6
```

### 样例输出 #1

```
3
```

## 提示

NOIP2004 普及组第 1 题

- 2021-10-27：增加一组 hack 数据

- 2022-06-05：又增加一组 hack 数据

  mycode:

  ```cpp
  #include <iostream>    
  #include <vector>
  int main(){
     int s=0,m=0;
     int max_day=0;
      int uh_day=0;
     std::vector<int>hour(7,0);
     for(int i=0;i<7;i++){
        std::cin>>s>>m;
        if(s+m>8){
           hour[i]=s+m;
           uh_day++;
        }      
     }
     int max=hour[0];
     for(int i=0;i<7;i++){
        if(max<hour[i]){
           max_day=i;
           max=hour[i];
        }
     }  
     if(uh_day==0){
       std::cout<<0;
     }else{
        std::cout<<max_day+1;
     }
  }                                                    
  ```

  

# P1089 [NOIP2004 提高组] 津津的储蓄计划

## 题目描述

津津的零花钱一直都是自己管理。每个月的月初妈妈给津津 $300$ 元钱，津津会预算这个月的花销，并且总能做到实际花销和预算的相同。

为了让津津学习如何储蓄，妈妈提出，津津可以随时把整百的钱存在她那里，到了年末她会加上 $20\%$ 还给津津。因此津津制定了一个储蓄计划：每个月的月初，在得到妈妈给的零花钱后，如果她预计到这个月的月末手中还会有多于 $100$ 元或恰好 $100$ 元，她就会把整百的钱存在妈妈那里，剩余的钱留在自己手中。


例如 $11$月初津津手中还有 $83$ 元，妈妈给了津津 $300$ 元。津津预计$11$月的花销是 $180$ 元，那么她就会在妈妈那里存 $200$ 元，自己留下 $183$ 元。到了 $11$ 月月末，津津手中会剩下 $3$ 元钱。


津津发现这个储蓄计划的主要风险是，存在妈妈那里的钱在年末之前不能取出。有可能在某个月的月初，津津手中的钱加上这个月妈妈给的钱，不够这个月的原定预算。如果出现这种情况，津津将不得不在这个月省吃俭用，压缩预算。


现在请你根据 $2004$ 年 $1$ 月到 $12$ 月每个月津津的预算，判断会不会出现这种情况。如果不会，计算到 $2004$ 年年末，妈妈将津津平常存的钱加上 $20\%$ 还给津津之后，津津手中会有多少钱。

## 输入格式

$12$ 行数据，每行包含一个小于 $350$ 的非负整数，分别表示 $1$ 月到 $12$ 月津津的预算。

## 输出格式

一个整数。如果储蓄计划实施过程中出现某个月钱不够用的情况，输出 $-X$，$X$ 表示出现这种情况的第一个月；否则输出到 $2004$ 年年末津津手中会有多少钱。

注意，洛谷不需要进行文件输入输出，而是标准输入输出。

## 样例 #1

### 样例输入 #1

```
290
230
280
200
300
170
340
50 
90 
80 
200
60
```

### 样例输出 #1

```
-7
```

## 样例 #2

### 样例输入 #2

```
290 
230 
280 
200 
300 
170 
330 
50 
90 
80 
200 
60
```

### 样例输出 #2

```
1580
```

 mycode:

```cpp
#include <iostream>    
#include <vector>
int main(){
   int last=0,s=0;
   std::vector<int>pre_m(12,0);
   for(int i=0;i<12;i++){
      std::cin>>pre_m[i];
   }
   for(int i=0;i<12;i++){
      pre_m[i]=300-pre_m[i];
      last+=pre_m[i];
      if (last>=100)
      {  
         s+=(last/100);
         last-=(last/100)*100;
      }else if(last<0){
         std::cout<<"-"<<i+1;
         return 0;
      }      
   }
   std::cout<<last+(s*100)*1.2;
}                                                    
```

# P1150 Peter 的烟

## 题目背景

**温馨提醒：吸烟有害健康，请勿尝试吸烟！**

## 题目描述

Peter 有 $n$ 根烟，他每吸完一根烟就把烟蒂保存起来，$k$（$k>1$）个烟蒂可以换一个新的烟，那么 Peter 最终能吸到多少根烟呢？

与某些脑筋急转弯不同的是，Peter 并不能从异次元借到烟蒂，抽完后再还回去。

## 输入格式

每组测试数据一行包括两个整数 $n, k$（$1 < n, k \le 10^8$）。

## 输出格式

对于每组测试数据，输出一行包括一个整数表示最终烟的根数。

## 样例 #1

### 样例输入 #1

```
4 3
```

### 样例输出 #1

```
5
```

## 样例 #2

### 样例输入 #2

```
10 3
```

### 样例输出 #2

```
14
```

## 提示

对于 $100\%$ 的数据，$1<n, k \le 10^8$。

mycode:

```cpp
#include <iostream>    
#include <vector>
int main(){
   int n=0,k=0;
   std::cin>>n>>k;
   int total_smoked=n;
   int butts=n;
   while (butts>=k)
   {
      int new_smokes=butts/k;
      total_smoked+=new_smokes;
      butts=butts%k+new_smokes;  
   }
   std::cout<<total_smoked;
}                                                    
```

